name: Monthly rootfs build

on:
  schedule:
    - cron: "0 2 1 * *"
  workflow_dispatch:

jobs:
  # ----------------------------------------------
  # Job 1: Build (Runs inside the Arch Container)
  # ----------------------------------------------
  build:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    outputs:
      new_tag: ${{ steps.tag_info.outputs.NEW_TAG }}
      release_date: ${{ steps.tag_info.outputs.RELEASE_DATE }}
    env:
      GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build deps
        # 移除 parted, util-linux, rsync（在容器中不再需要）
        run: |
          pacman -Sy --noconfirm base base-devel arch-install-scripts git

      - name: Build rootfs directory
        # 注意：这里我们不再需要 GPG 密钥，因为签名将在主机上进行
        run: |
          chmod +x build.sh
          ./build.sh

      - name: Calculate release date and tag name
        id: tag_info
        run: |
          RELEASE_DATE=$(date +'%Y-%m-%d')
          TIMESTAMP=$(date +%s)
          NEW_TAG="${RELEASE_DATE}-${TIMESTAMP}"
          echo "RELEASE_DATE=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Calculated tag: $NEW_TAG"

      # 关键修改：上传 ROOTFS 目录作为产物
      - name: Upload rootfs directory artifact
        uses: actions/upload-artifact@v4
        with:
          name: rootfs-directory # 修改产物名称
          path: out/rootfs # 上传目录
          retention-days: 7

  # ----------------------------------------------
  # Job 2: Create DD Image (Runs on the Host Runner)
  # ----------------------------------------------
  create-image:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download rootfs directory artifact
        uses: actions/download-artifact@v4
        with:
          name: rootfs-directory
          path: out/

      - name: Install DD image tools on Host
        run: |
          # 在 Host (ubuntu-latest) 上安装所需的工具
          sudo apt-get update
          # parted 用于分区，e2fsprogs 用于 mkfs.ext4, rsync 用于数据复制
          sudo apt-get install -y parted e2fsprogs rsync

      - name: Setup GPG on Host
        run: |
          # 重新导入 GPG 密钥以便签名最终镜像
          echo "${{ secrets.GPG_PRIVATE_KEY }}" > /tmp/gpg.key
          gpg --batch --import /tmp/gpg.key
          rm -f /tmp/gpg.key

      - name: Create DD Image on Host (using losetup, parted, mkfs)
        env:
          ROOTFS_DIR: out/rootfs
          IMAGE_FILE: out/fireflyos.img
          IMAGE_SIZE_MB: 2048 # 2GB 镜像
          GPG_KEY: ${{ secrets.GPG_KEY }}
        run: |
          set -euo pipefail
          
          # 1. 变量设置
          IMAGE_FILE="$IMAGE_FILE"
          ROOTFS_DIR="$ROOTFS_DIR"
          MOUNT_POINT=$(mktemp -d)

          # 2. 创建一个空镜像文件
          truncate -s "${IMAGE_SIZE_MB}M" "$IMAGE_FILE"

          # 3. 创建分区表 (MBR) 和一个主分区 (ext4)
          sudo parted -s "$IMAGE_FILE" mklabel msdos
          # partprobe 帮助内核识别新创建的分区表
          sudo partx -a "$IMAGE_FILE"

          # 4. 将镜像关联到 loop 设备
          LOOP_DEV=$(sudo losetup -f --show "$IMAGE_FILE")
          if [ -z "$LOOP_DEV" ]; then
              echo "错误：无法找到可用的 loop 设备。"
              exit 1
          fi
          echo "-> 镜像已关联到 $LOOP_DEV"
          
          # 确保分区设备节点存在
          sudo kpartx -a "$LOOP_DEV"
          PART_DEV="/dev/mapper/$(basename $LOOP_DEV)p1"

          # 等待设备创建
          sleep 2

          # 5. 在分区上创建 ext4 文件系统
          echo "-> 正在格式化分区 $PART_DEV..."
          # 使用 -F 强制格式化，-L 设置卷标
          sudo mkfs.ext4 -F -L ROOTFS "$PART_DEV"

          # 6. 挂载分区并复制 rootfs 内容
          echo "-> 正在挂载 $PART_DEV 到 $MOUNT_POINT..."
          sudo mount "$PART_DEV" "$MOUNT_POINT"

          echo "-> 正在将 rootfs 内容复制到镜像..."
          # 确保 rsync 复制所有内容，包括隐藏文件和权限
          sudo rsync -a "$ROOTFS_DIR/" "$MOUNT_POINT/"

          # 7. 卸载并清理
          echo "-> 卸载分区并分离 loop 设备..."
          sudo umount "$MOUNT_POINT"
          sudo kpartx -d "$LOOP_DEV"
          sudo losetup -d "$LOOP_DEV"
          rm -rf "$MOUNT_POINT"
          
          # 8. 签名最终镜像
          echo "==> Signing the image..."
          gpg --detach-sign --armor --local-user "$GPG_KEY" -o "${IMAGE_FILE}.sig" "$IMAGE_FILE"
          
          echo "DD image creation complete: $IMAGE_FILE"
      
      - name: Upload final DD image artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-image # 最终产物名称
          path: out/fireflyos.img
          retention-days: 7

  # ----------------------------------------------
  # Job 3: Release (Runs on the Host Runner)
  # ----------------------------------------------
  release:
    runs-on: ubuntu-latest
    needs: create-image # 依赖 create-image 任务
    permissions:
      contents: write 
    steps:
      - name: Checkout code (for git tagging)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download final image artifact
        uses: actions/download-artifact@v4
        with:
          name: final-image # 下载最终产物
          path: out/
        
      # ... Tagging steps (保持不变) ...
      - name: Create and Push Git Tag
        id: create_tag
        env:
          NEW_TAG: ${{ needs.build.outputs.new_tag }}
          RELEASE_DATE: ${{ needs.build.outputs.release_date }}
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          REMOTE_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git remote set-url origin $REMOTE_URL

          if git ls-remote --tags origin | grep "refs/tags/$NEW_TAG"; then
            echo "Tag $NEW_TAG already exists. Skipping tag creation."
            echo "tag_created=false" >> $GITHUB_OUTPUT
          else
            git tag -a "$NEW_TAG" -m "Monthly automated release for $RELEASE_DATE"
            git push origin "$NEW_TAG"
            echo "Tag $NEW_TAG created and pushed successfully."
            echo "tag_created=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Create GitHub Release with Artifact
        if: steps.create_tag.outputs.tag_created == 'true'
        uses: softprops/action-gh-release@v2
        with:
          files: out/fireflyos.img
          tag_name: ${{ needs.build.outputs.new_tag }}
          name: "${{ needs.build.outputs.new_tag }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
